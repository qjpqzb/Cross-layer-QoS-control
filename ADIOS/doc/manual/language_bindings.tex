\chapter{Language bindings}

ADIOS provides the following wrappers to support various programming environments; 
\begin{itemize}
\item{\bf Java} -- Write and Read ADIOS-BP files, with old read API
\item{\bf Python/Numpy} -- Write and Read ADIOS-BP files, with old read API
%\item{\bf Matlab} Read ADIOS-BP files, with own matlab/ADIOS commands
\end{itemize}

In this chapter, we will describe how one can use ADIOS wrappers and provide a few example codes.

\section{Java support}
\label{section-bindings-java}
The Java wrapper program consists of a set of Java classes defined with a single namespace, \verb+gov.ornl.ccs+. A list of classes is as follows:
\begin{itemize}
\item{\bf Adios} -- Provides functions to call init/free, write, and no-XML related APIs. All functions are static.
\item{\bf AdiosFile} -- Related with Read APIs. Represents ADIOS file structure.
\item{\bf AdiosGroup} -- Related with Read APIs. Represents ADIOS group structure. 
\item{\bf AdiosVarinfo} -- Related with Read APIs. Represents ADIOS varinfo structure.
\item{\bf AdiosDatatype} -- Enumeration class for ADIOS data types.
\item{\bf AdiosFlag} -- Enumeration class for ADIOS flags.
\item{\bf AdiosBufferAllocWhen} -- Enumeration class for ADIOS buffer allocation flags.
\end{itemize}

\subsection{Adios class}
This class provides static functions for initialization, finalization, writing, and no-XML related APIs. The list of functions and signatures are as follows:
\begin{lstlisting}[language=Java,caption={Member functions in the Adios class},label={}]
    /* Call adios_init */
    public static int Init(String xml_fname)

    /* Call adios_open. Return a group handler */
    public static long Open(String group_name, String file_name, 
                            String mode, long comm)

    /* Call adios_group_size and return the total size */
    public static long SetGroupSize(long fh, long group_size)

    /* Call adios_write and return the total size */
    public static long Write (long fh, String var_name, byte value)
    public static long Write (long fh, String var_name, int value)
    public static long Write (long fh, String var_name, long value)
    public static long Write (long fh, String var_name, float value)
    public static long Write (long fh, String var_name, double value)
    public static long Write (long fh, String var_name, byte[] value)
    public static long Write (long fh, String var_name, int[] value)
    public static long Write (long fh, String var_name, long[] value)
    public static long Write (long fh, String var_name, float[] value)
    public static long Write (long fh, String var_name, double[] value)

    /* Call adios_close */
    public static int Close (long fh)

    /* Call adios_finalize */
    public static int Finalize (int id)

    /* Call MPI_Init */
    public static int MPI_Init(String[] args)

    /* Call MPI_Comm_rank */
    public static int MPI_Comm_rank(long comm)

    /* Call MPI_Comm_size */
    public static int MPI_Comm_size(long comm)

    /* Call MPI_Finalize */
    public static int MPI_Finalize()

    /* Get MPI_COMM_WORLD */
    public static long MPI_COMM_WORLD()

    /* Call adios_init_noxml */
    public static int Init_Noxml()

    /* Call adios_allocate_buffer */
    public static int AllocateBuffer(AdiosBufferAllocWhen when, long size)

    /* Call adios_declare_group */
    public static long DeclareGroup(String name, String time_index, 
                                    AdiosFlag stats)

    /* Call adios_define_var */
    public static int DefineVar(long group_id, String name, String path, 
                                AdiosDatatype type, String dimensions, 
                                String global_dimensions, 
                                String local_offsets)

    /* Call adios_define_attribute */
    public static int DefineAttribute(long group_id, String name, 
                                String path, AdiosDatatype type, 
                                String value, String var)

    /* Call adios_select_method */
    public static int SelectMethod(long group_id, String method, 
                                String parameters, String base_path)
\end{lstlisting}

\subsection{AdiosFile, AdiosGroup, and AdiosVarinfo classes}
AdiosFile, AdiosGroup, and AdiosVarinfo classes represent \verb+ADIOS_FILE+, \verb+ADIOS_GROUP+, \verb+ADIOS_VARINFO+ structure, respectively, defined in \verb+adios_read_v1.h+. The following is a skeletal descriptions of those classes and member functions.

\begin{lstlisting}[language=Java,caption={Class definitions of AdiosFile, AdiosGroup, and AdiosVarinfo},label={}]
public class AdiosFile
{
    /* Call adios_fopen */
    public int open(String path, long comm)
    
    /* Call adios_fclose */
    public int close()
    
    /* Print contents for debugging purpose */
    public String toString()
}

public class AdiosGroup
{
    /* Constructor. Need AdiosFile instance */
    public AdiosGroup(AdiosFile file)
    
    /* Call adios_gopen */
    public int open(String grpname)
    
    /* Call adios_gclose */
    public int close()
    
    /* Print contents for debugging purpose */
    public String toString()
}

public class AdiosVarinfo
{
    /* Constructor. Need AdiosGroup instance */
    public AdiosVarinfo(AdiosGroup group)
    
    /* Call adios_inq_var */
    public int inq(String varname)
    
    /* Call adios_free_varinfo */
    public int close()
    
    /* Call adios_read_var */
    public double[] read(long[] start, long[] count)
    
    /* Print contents for debugging purpose */
    public String toString()
}
\end{lstlisting}

\subsection{AdiosDatatype, AdiosFlag, and AdiosBufferAllocWhen classes}
AdiosDatatype, AdiosFlag, and AdiosBufferAllocWhen are enumeration classes representing \verb+ADIOS_DATATYPES+, \verb+ADIOS_FLAG+, \verb+ADIOS_BUFFER_ALLOC_WHEN+ enum type, respectively, defined in \verb+adios_types.h+. The following is a skeletal descriptions of those classes and member functions.
\begin{lstlisting}[language=Java,caption={Enum classes},label={}]
public enum AdiosDatatype {
    UNKNOWN(-1),             /* (SIZE) */
    BYTE(0),                 /* (1) */
    SHORT(1),                /* (2) */
    INTEGER(2),              /* (4) */
    LONG(4),                 /* (8) */
    
    UNSIGNED_BYTE(50),       /* (1) */
    UNSIGNED_SHORT(51),      /* (2) */
    UNSIGNED_INTEGER(52),    /* (4) */
    UNSIGNED_LONG(54),       /* (8) */
    
    REAL(5),                 /* (4) */
    DOUBLE(6),               /* (8) */
    LONG_DOUBLE(7),          /* (16) */
    
    STRING(9),               /* (?) */
    COMPLEX(10),             /* (8) */
    DOUBLE_COMPLEX(11);      /* (16) */
}

public enum AdiosFlag {
    UNKNOWN(0),
    YES(1), 
    NO(2);
}

public enum AdiosBufferAllocWhen {
    UNKNOWN(0),
    NOW(1), 
    LATER(2);

}
\end{lstlisting}


\subsection{Example}
An example of Java program to call ADIOS functions is as follows:
\begin{lstlisting}[language=Java,caption={Example Java wrapper code},label={}]
import gov.ornl.ccs.*;
import java.nio.ByteBuffer;

public class AdiosNoxmlExample
{
    // The main program
    public static void main(String[] args)
    {
        Adios.MPI_Init(new String[0]);
        long comm = Adios.MPI_COMM_WORLD();
        int rank = Adios.MPI_Comm_rank(comm);
        int size = Adios.MPI_Comm_size(comm);

        Adios.Init_Noxml();
        Adios.AllocateBuffer(AdiosBufferAllocWhen.NOW, 10);

        long group_id = Adios.DeclareGroup("restart", "iter", 
                                           AdiosFlag.YES);
        Adios.SelectMethod(group_id, "MPI", "", "");
        Adios.DefineVar(group_id, "NX", "", 
                        AdiosDatatype.INTEGER, "", "", "");
        Adios.DefineVar(group_id, "G", "", 
                        AdiosDatatype.INTEGER, "", "", "");
        Adios.DefineVar(group_id, "O", "", 
                        AdiosDatatype.INTEGER, "", "", "");
        Adios.DefineVar(group_id, "temperature", "", 
                        AdiosDatatype.DOUBLE, "NX", "G", "O");

        long adios_handle = Adios.Open("restart", "adios_noxml.bp", 
                                       "w", comm);

        int NX = 10; 
        int G = NX * size;
        int O = NX * rank;

        double[] t = new double[NX];
        for (int i = 0; i < NX; i++) {
            t[i] = rank * NX + (double) i;
        }

        long groupsize = 4 + 4 + 4 + 8 * (1) * (NX);
        
        long adios_totalsize = Adios.SetGroupSize(adios_handle, groupsize);
        
        Adios.Write (adios_handle, "NX", NX);
        Adios.Write (adios_handle, "G", G);
        Adios.Write (adios_handle, "O", O);
        Adios.Write (adios_handle, "temperature", t);
        Adios.Close (adios_handle);
        
        Adios.Finalize (rank);        
        Adios.MPI_Finalize();
    }
}
\end{lstlisting}

\section{Python/Numpy support}
\label{section-bindings-numpy}
We developed a ADIOS python wrapper by using Cython. Numpy, a scientific module for Python, is a mandatory requirement. 

\subsection{APIs for Writing and No-XML}
The ADIOS python/numpy wrapper provides functions to call ADIOS write and no-XML related APIs as follows (defined in Cython syntax). MPI related arguments can be ignored in the serial binding.
\begin{lstlisting}[language=cython,caption={Functions for writing and No-XML},label={},]
""" Call adios_init """
cpdef init(char * config, MPI_Comm comm = MPI_COMM_WORLD)

""" Call adios_open """
cpdef int64_t open(char * group_name,
                   char * name,
                   char * mode,
                   MPI.Comm comm = MPI.COMM_WORLD)

""" Call adios_group_size """
cpdef int64_t set_group_size(int64_t fd_p, uint64_t data_size)

""" Call adios_write """
cpdef int write (int64_t fd_p, char * name, np.ndarray val)
cpdef int write_int (int64_t fd_p, char * name, int val)
cpdef int write_long (int64_t fd_p, char * name, long val)
cpdef int write_float (int64_t fd_p, char * name, float val)

""" Call adios_read """
cpdef int read(int64_t fd_p, char * name, np.ndarray val)

""" Call adios_close """
cpdef int close(int64_t fd_p)

""" Call adios_finalize """
cpdef finalize(int mype = 0)

""" Call adios_init_noxml """
cpdef int init_noxml(MPI_Comm comm = MPI_COMM_WORLD):

""" Call adios_allocate_buffer """
cpdef int allocate_buffer(int when,
                          uint64_t buffer_size)

""" Call adios_declare_group """
cpdef int64_t declare_group(char * name,
                            char * time_index,
                            int stats)

""" Call adios_define_var """
cpdef int define_var(int64_t group_id,
                     char * name,
                     char * path,
                     int type,
                     char * dimensions,
                     char * global_dimensions,
                     char * local_offsets)

""" Call adios_define_attribute """
cpdef int define_attribute (int64_t group,
                            char * name,
                            char * path,
                            int type,
                            char * value,
                            char * var)

""" Call adios_select_method """
cpdef int select_method (int64_t group,
                         char * method,
                         char * parameters,
                         char * base_path)
\end{lstlisting}

\subsection{APIs for Reading}
After ADIOS version 1.9.0, ADIOS python/numpy wrapper provides Numpy style array notation. For an example, the following commands are equivalent:
\begin{lstlisting}[language=Python,caption={Numpy style reading},label={},]
>>> f['temperature'].read(); 
>>> f['temperature'][:]
\end{lstlisting}

Numpy style slicing is supported in a same way:
\begin{lstlisting}[language=Python,caption={Numpy style slicing},label={},]
>>> f['temperature'].read(offset=(0,0), count=(2,5)); 
>>> f['temperature'][0:2,0:5]
\end{lstlisting}

More details of read APIs are as follows (defined in Cython syntax). Like in the writing, MPI related arguments can be ignored in the serial binding.
\begin{lstlisting}[language=cython,caption={Read functions},label={},]
cdef class file:
    """
    file class for Adios file read and write.

    Args:
        fname (str): filename.
        method_name (str, optional): Adios read method (default: 'BP').
        comm (MPI_Comm, optional): MPI_comm for parallel read/write 
                                   (default: MPI_COMM_WORLD).
        is_stream (bool, optional): Set True if use stream reader 
                                    (default: False).
        lock_mode (int, optional): ADIOS_LOCKMODE for stream reader 
                                   (default: ADIOS_LOCKMODE_ALL).
        timeout_sec (float, optional): Timeout seconds for stream reader
                                       (default: 0.0) .
    """

    property name:
        """ The filename (or stream name) associated with. """
    property nvars:
        """ The number of variables. """
    property nattrs:
        """ The number of attributes. """
    property current_step:
        """ The current timestep index. """
    property last_step:
        """ The last timestep index. """
    property endianness:
        """ The endianness of the stored data. """
    property version:
        """ The version of Adios. """
    property file_sizec:
        """ The size of Adios file. """
    property is_stream:
        """ Indicating reader type; file reader or stream reader """

    cpdef close(self):
        """ Close the open file. """
        
    cpdef printself(self):
        """ Print native ADIOS_FILE structure. """

    cpdef advance(self, int last = 0, float timeout_sec = 0.0):
        """
        Advance a timestep for stream reader.

        Args:
            last (int, optional): last timestep index (default: 0).
            timeout_sec (float, optional): timeout seconds (default: 0.0).

        Returns:
            int: 0 if successful, non-zero otherwise.
        """
        
    def __getitem__(self, varname):
        """
        Return Adios variable.

        Args:
            varname (str): variable name.

        Raises:
            KeyError: If no varname exists.

        """
        
    def __repr__(self):
        """ Return string representation. """


cdef class var:
    """
    Adios variable class.

    Unlike attributes whose values are populated on initialization,
    variable's values will be returned by explicitly calling read() or
    array access interface ([]).  

    Args:
        file (file): Associated file class
        name (str): variable name

    Note:
        Users do not need to create this class manually.
    """
    
    property name:
        """ The variable name. """
    
    property varid:
        """ Internal variable id. """
    
    property dtype:
        """ Variable type as in numpy.dtype. """

    property ndim:
        """ The number of dimensions of the variable. """

    property dims:
        """ The shape of the variable. """

    property nsteps:
        """ The number of time steps of the variable. """

    cpdef close(self):
        """ Close and free variable information """

    cpdef advance(self):
        """ Update variable information after the stream advanced """

    cpdef read(self, tuple offset = (), tuple count = (), from_steps = None, 
                     nsteps = None, fill = 0):
        """ Perform read.

        Read data from an ADIOS BP file. Subset reading is
        supported. Without any options, this will read out a whole
        data.

        Args:
            offset (tuple of int, optional): offset (default: ())
            count (tuple of int, optional): count (default: ())
            from_steps (int, optional): starting step index (default: None)
            nsteps (int, optional): number of time dimensions (default: None)
            fill (value, optional): default fill value (default: 0)

        Returns:
            NumPy ndarray
            
        Raises:
            IndexError: If dimension is mismatched or out of the boundary.

        """

    cpdef printself(self):
        """ Print native ADIOS_VARINFO structure. """

    def __repr__(self):
        """ Return string representation. """
        

cdef class attr:
    """
    Adios attribute class.
    
    Attribute values are loaded on initialization.

    Args:
        attr_name (str): attribute name

    Raises:
        KeyError: If no attribute name exists.

    Note:
        Users do not need to create this class manually.        
    """

    property name:
        """ The attribute name """
    property dtype:
        """ The attribute type as in numpy.dtype """
    property value:
        """ The attribute's value """

    def __repr__(self):
        """ Return string representation. """
\end{lstlisting}

\subsection{Utility functions}
Besides exposing ADIOS APIs directly, we provide utility functions users can call in python in a simple way

\begin{lstlisting}[language=cython,caption={Utility functions},label={},]
def readvar(fname, varname):
    """ Retrieve a variable value from an Adios file.

    Args:
        fname (str): Adios file name
        varname (str): Variable name to retrieve

    Returns:
        NumPy ndarray: variable value
    """

def bpls(fname):
    """ Return meta data of an Adios file as a Python dictionary object.

    Args:
        fname (str): Adios file name

    Returns:
        dict: Adios file meta data
    """
\end{lstlisting}

\subsection{Examples}
Examples of using ADIOS Python/Numpy functions are shown below. The first example is to write and read ADIOS BP files with a single process. You can find the code in the source distribution: \verb+wrapper/numpy/tests/test_adios.py+.

\begin{lstlisting}[language=ADIOS-python,caption={A Python/Numpy example for writing/reading ADIOS BP file},label={},]
""" Import ADIOS Python/Numpy wrapper """
import adios as ad
import numpy as np

""" Writing """
print "\n>>> Writing ...\n"

ad.init("config.xml")
fd = ad.open("temperature", "adios_test.bp", "w")

NX = 10
size = 2
groupsize =  4 + 4 + 8 * size * NX
t = np.array(range(NX*size), dtype=np.float64)
tt = t.reshape((size, NX))
ad.set_group_size(fd, groupsize)
ad.write_int(fd, "NX", NX)
ad.write_int(fd, "size", size)
ad.write(fd, "temperature", tt)
ad.close(fd)

ad.finalize()

""" Reading """
print "\n>>> Reading ...\n"

f = ad.file("adios_test.bp")
f.printself()

v = f.var['temperature']
v.printself()

val = v.read()
print val
assert ((tt == val).all())
f.close()

\end{lstlisting}

The above code can be executed as follows:
\begin{lstlisting}
python test_adios.py
\end{lstlisting}

The second example is about parallel writing and reading by using multiple MPI processes. You can find the code in the source distribution: \verb+/wrapper/numpy/tests/test_adios_mpi.py+.

\begin{lstlisting}[language=ADIOS-python,caption={A Python/Numpy example for parallel writing/reading ADIOS BP file},label={},]
""" Import ADIOS Python/Numpy wrapper """
import adios_mpi as ad
import numpy as np
""" Require MPI4Py installed """
from mpi4py import MPI

""" Init """
comm = MPI.COMM_WORLD
rank = comm.Get_rank()
size = comm.Get_size()

""" Writing """
print "\n>>> Writing ... (rank = %d)\n" % rank

ad.init("config_mpi.xml", comm)
fd = ad.open("temperature", "adios_test_mpi.bp", "w", comm)

NX = 10
groupsize =  4 + 4 + 4 + 8 * 1 * NX
t = np.array(range(NX), dtype=np.float64) + rank*NX
ad.set_group_size(fd, groupsize)
ad.write_int(fd, "NX", NX)
ad.write_int(fd, "rank", rank)
ad.write_int(fd, "size", size)
ad.write(fd, "temperature", t)
ad.close(fd)

ad.finalize()

""" Reading """
if rank == 0:
    print "\n>>> Reading ...\n"

    f = ad.file("adios_test_mpi.bp", comm=MPI.COMM_SELF)
    f.printself()

    v = f.var['temperature']
    v.printself()

    val = v.read()
    print val
    assert (int(sum(sum(val))) == (size*NX-1)*(size*NX)/2)
    f.close()

\end{lstlisting}

The above code can be executed as follows:
\begin{lstlisting}
mpiexec -n 4 python ./test_adios.py
\end{lstlisting}
