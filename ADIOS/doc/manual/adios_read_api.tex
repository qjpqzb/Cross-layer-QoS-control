\chapter{ADIOS Read API}
\label{chapter:read_api}

\section{Introduction}

The second version of the ADIOS Read API (introduced in ADIOS 1.4) is designed to handle both files on disk and data sets in memory staging areas. Non-blocking and chunking read is introduced to enable concurrent processing of some part of the requested data while other parts are being retrieved for methods that support it.  A Selection interface is introduced to define subsets of datasets other than a simple bounding box. 


\subsection{Changes from version 1}
The original version of ADIOS Read API (in ADIOS releases 1.0--1.3.1) provides a (1) grouped view of variables in an ADIOS-BP file with (2) time as an extra dimension. ADIOS applications can write multiple, separate groups of variables into one file. They can also write multiple steps of a group into one file. When opening a file for reading, each group is conceptually separated and thus has to be opened separately. Also, an N--dimensional variable with multiple steps is presented as an N+1--dimensional variable, with time represented as the slowest dimension (like in NetCDF). These two representations have been eliminated in the new API, both for the sake of supporting streams with the same API as files and thus enable the transition from file-based analytics and visualization to staging environments where data sets are passed around without touching permanent storage.

In the new API, all variables of all groups are presented at once when opening the file. Nevertheless, some extra functions are provided in the API to get the list of groups written into the file (\verb+adios_get_grouplist()+) and to restrict the view of variables and attributes to a certain group (\verb+adios_group_view()+) in case some application would need this artificial separation. 

Time is completely eliminated as a concept from the read API. Now one sees the output steps as they are; just steps. An N--dimensional variable written M times into the same file is represented as an N--dimensional variable with M steps available to read. From permanently stored datasets (files), the user can still read multiple steps at once and store in the user-provided contigous memory but with arguments separate from the spatial dimension specification.

\subsection{Concepts}

\begin{itemize}
    \item {\em Reader} is an application reading data using ADIOS
    \item {\em Writer} is an application writing output data using ADIOS
    \item {\em Reading methods} are different reading codes in ADIOS from which a Reader can choose one, e.g. for reading from a file, or from the memory of the Writer. 
\end{itemize}


\subsubsection{Staging}
Staging here means that data is in memory somewhere and an ADIOS method presents that data to a reader as a stream. That is, it has to be opened, its content can be discovered, it contains variables and attributes, and it has to be closed afterwards. Different staging scenarios exist and are under development by various teams:

\begin{itemize}
    \item A staging server with its own compute nodes and memory, stores the output of writing applications, allows connections from several applications and serves read requests. 
    \item A staging library embedded in the reading application, connects directly to a writing application and pulls the requested data out of the writer's memory. 
    \item A staging library like the above with the specialization that both writer and reader occupies the same (multi-core) compute node and shares memory.   
\end{itemize}

\noindent ADIOS 1.4 comes with the DataSpaces method that is an implementation of the first scenario. Methods for the other two scenarios are coming in the near future. 

\subsubsection{Streams and Steps}
Simulations usually write the same data set regularly over time, so a file or a series of files contains the same set of variables written many times. The dataset written between one adios\_open and adios\_close calls is called {\em STEP} and not "time" or "timesteps" to avoid confusing users about what time actually means. A {\em STREAM} differs from a file containing multiple steps only in the handling of steps. In a file on disk, all steps are available at all times to a reader. In a stream, only one step is available at a time to read, and as newer steps are becoming available from the writer, older steps may disappear. The ADIOS Read API provides two different open functions for streams and files. Nevertheless, a file can be handled in an application as a stream, i.e., by reading one step at a time, processing it, then advancing to the next step. Users are encouraged to write their code with streaming in mind, so that their file processing code can be used in a staging environment without code modification. 

\vspace{6pt}
\noindent {\bf Note:} A stream in ADIOS is {\bf not} a byte stream! The unit of the stream is one output Step of the Writer, so it still can be much larger than the available memory in the Reader.
\vspace{6pt}

In case of opening a file in file mode, each variable may have a different numberof steps, which is known at the time of opening the file. The number of steps value can be inquired for each variable separately (this value is always 1 for all variables in a stream). Then the application can read some steps of a variable at once, which may be different from the "global steps" written into the file. E.g., if a variable is written at every other output steps (1,3,5,...,n), then it will have half as many steps as the file itself has but its steps are addressed as 0,1,2...$\lceil n/2\rceil-1$.

In case of streams a step is the feature of the stream, not of the individual variables. There is no individual counting of the variables so the application has to count them itself if needed. 


\subsubsection{Locking strategies}
Locking is not used for files, but in a staging environment there are different strategies to deal with disappearing steps of datasets. A daredevil reader may tell the API to not block the writing application at all ({\em ADIOS\_LOCKMODE\_NONE}), i.e., to allow for loosing the opened data set any time if space is needed for storing newer steps of the writer's output. A safer way to handle complete steps is to lock the currently opened step ({\em ADIOS\_LOCKMODE\_CURRENT}). If the writer has more output in the meantime and there is not enough space for staging, an earlier or even a more recent step can be removed by the staging method. To ensure correct execution of  rigid readers, current and all more recent steps should be locked so that they can be read one-by-one without loosing them ({\em ADIOS\_LOCKMODE\_ALL}). This strategy, however, can certainly block the writing application if it has to wait for some available space to become free in the staging area.

Note, however, that specific staging methods may not support all locking mechanisms, or the actual locking mechanism would depend on their configuration and runtime set-up. E.g., the DataSpaces method in \adiosversion only supports the {\em ADIOS\_LOCKMODE\_CURRENT} locking strategy, although the DataSpaces server can also be started up with a custom locking that enforces synchronized steps of alternating writes and reads. The three locking options are kept in the read API with the hope that some staging methods would support all of them in the future. 

\subsubsection{Chunks}
Chunking allows for processing large data in small pieces concurrently while other pieces are being transferred.

\emph{Note: In \adiosversion, chunking is implemented only "functionally" in any method; all of them will just read the whole variable at once.}

A read request of a variable for one step can be served in multiple pieces. The reader should be able to receive parts of the whole requested dataset and process them one by one, instead of expecting the whole data set arriving in one piece, ordered in memory. We call these pieces or parts returned by the reading method to the reader as \emph{chunks}. In ADIOS, chunks are closely related to the individual outputs of writing processes. Therefore, readers should expect to receive one chunk per writer whose output partly matches the query.

\subsection{Selections}
Selection is some subset of a variable. ADIOS reading methods support 

\begin{itemize}
    \item Contiguous {\em Bounding Box}es (compact ranges in all dimensions of a variable), 
     \item A set of individual {\em Points}
    \item Individual selection of a block written by one writer process
         \item "Auto" selection for a special case of asking for locally available data in in-situ staging frameworks
\end{itemize}

\noindent Note that the bounding box was supported in the ADIOS Read API v1 implicitly, as extra arguments in the adios\_read\_var calls, and individual blocks were accessible with the special function adios\_read\_local\_var. 

All reading methods understand and can serve read requests over such selections.  

\section{How to use the read functions}
First, before opening a file/stream, we have to choose a reading method and initialize it with the \linebreak \verb+adios_read_init_method()+. Also, an \verb+adios_read_finalize_method()+ is necessary at the end of the application run. Note, that there is a separate initialization call for each read method the application intends to use.

A file has to be opened with \verb+adios_read_open_file(fname, method, comm)+ if the application wants to handle it as file (all steps accessible at once). A name, a read method and an MPI communicator should be provided. A stream (or a file handled as a stream) has to be opened with \linebreak
\verb+adios_read_open(fname, method, comm, lock_mode, timeout_sec)+.  A locking strategy has to be specified and some timeout can be specified for waiting for the stream to appear.  

In C, a transparent data struct is returned (\verb+ADIOS_FILE+), which enumerates the list of variables and attributes,  the current step and the available steps in the staging memory at the time of opening. The available steps are updated whenever seeking with \verb+adios_advance_step()+. Seeking is allowed to the next available step or to the last (newest) available step, with the possible errors of not finding any new step or finding that the stream has terminated. The current step can be released without advancing the step too, to free resources in the staging area. This optimization call is highly encouraged in every application to give free space to the writing application as early as possible. 

To read a subset of a variable, a selection object has to be created. The selection is independent from the variable (e.g. a bounding box) and from the opened file/stream, so it can be reused for reading many similar variables. 

When reading data, several read operations are first scheduled (\verb+adios_schedule_read_var()+), then \verb+adios_perform_reads()+ is called to start/do the actual reading. In blocking mode, this function returns when all reading has been finished and all result is stored in the user provided memory (provided separately for each variable in the schedule step). 

In non-blocking mode, this function returns as soon as possible and the application has to check for variables becoming available with \verb+adios_check_reads()+. This function returns zero or one "chunk".
If memory was provided to a variable in the schedule call, a single chunk will eventually be returned here that describes the whole variable. If memory was not provided, the chunking read mode should use an internal buffer in ADIOS to store and return a partial result. It depends on the size of the internal buffer and the number of writers of the requested piece that how many chunks will be needed for each scheduled read. Each chunk is a contiguous subset of the requested variable, but it is the application's own business how to reorganize the chunks into the complete request. This function returns one chunk at a time, which should be processed before calling this function again. It should be called repeatedly until the function tells the application that all reads have been completed.

Reading is concluded with closing the file/stream with \verb+adios_close()+ and deleting the ADIOS objects created to schedule the reading (selections with \verb+adios_selection_delete()+ and inquired structures with \verb+adios_free_varinfo()+).

\section{Notes}

\emph{Dimensions of arrays are reported differently for C and Fortran}.
When reading from a different language than writing (Fortran vs. C), 
the storage order of the dimensions 
is the opposite. Instead of transposing multidimensional arrays in memory to order 
the data correctly at read time, simply the dimensions are reported reversed. 

\emph{Metadata rich footer enables fast information retrieval}.
Since the BP file format is metadata rich, and the metadata is immediately accessible 
in the footer of the file, we can get a lot of information without accessing the file again
after the open call. 
The open function returns the list of variables and attributes. 
Type and dimensionality as well as the actual value of a scalar variable is returned by adios\_inq\_var.
Another inquiry extends the information with statistics (minimum, maximum, average and
standard deviation globally and for each writer process separately). Similarly, another inquiry
extends the information with dimensionality for each writer process 
(i.e. the detailed decomposition of a variable).


\emph{Steps start from 0}, even in Fortran applications (just because ADIOS is written in C, where everything starts from 0). 


\section{Read C API description}

Please consult the \verb+adios_read_v2.h+ for the data structures and functions discussed here. In the source code, do not include this header file directly, but \verb+adios_read.h+. The sequence of reading in a variable from the BP file is

\begin{itemize}
\renewcommand{\labelitemi}{$-$}
\item initialize the reading method (once per program run)

\item open file/stream

\item inquiry the variables to get type and dimensions

\item allocate memory for the variables

\item create a selection object for each variable (reusable for similar subsets)

\item schedule reads for all variables (whole or part of it)

\item perform the reads

\item free varinfo data structure

\item close group

\item close file

\item finalize the read method (once per program run)
\end{itemize}

\noindent Example codes using the C API are 

\begin{itemize}
\renewcommand{\labelitemi}{$-$}
\item examples/C/global-array/adios\_read\_global
\item tests/suite/programs/write\_read.c
\end{itemize}


\subsection{adios\_errmsg / adios\_errno}

\begin{lstlisting}
int    adios_errno
char * adios_errmsg()
\end{lstlisting}

\noindent If an error occurrs during the call of a C api function, it either returns NULL 
(instead of a pointer to an allocated structure) or a negative number. It also 
sets the integer adios\_errno variable (the negative return value is actually 
is this adios\_errno value). Moreover, it prints the error message into an internal 
buffer, which can be retrieved by adios\_errmsg(). 

Note that adios\_errmsg() returns the pointer to the internal buffer instead of 
duplicating the string, so refrain from writing anything into it. Moreover, only the 
last error message is available at any time.


\subsection{adios\_read\_init\_method}

Initialize a reading method before opening a file/stream with using 
the method. 
Staging methods perform the connection/disconnection to the staging server once during init/finalize.

\begin{itemize}
\item{\bf method} Read method to use.
\item{\bf comm} MPI communicator of all processes participating in a file/stream operation
\item{\bf parameters} A series of name=value pairs separated by ";".  E.g. "max\_chunk\_size=200; app\_id = 1".
List of parameters is documented for each method separately. 
\end{itemize}

\noindent The function returns 0 on success, $<0$ on an error.

The methods supported in \adiosversion are

\begin{itemize}
\item{\bf ADIOS\_READ\_METHOD\_BP}   Read from ADIOS BP file. 
Every reading process will access the file(s) to serve its own reading needs.

\item{\bf ADIOS\_READ\_METHOD\_BP\_AGGREGATE}   Read from ADIOS BP file. 
Only the aggregators will access the file(s) to serve all reading requests. They gather the scheduled reads from all reader processes, optimize the read operations and then distribute the requested data to all readers. Specify the number of aggregators by adding \verb+"num_aggregators=<N>"+ to the parameters of this function call.

\item{\bf ADIOS\_READ\_METHOD\_DATASPACES} Read from staging memory using DataSpaces. The writer applications must use the DATASPACES transport method when writing. See Section~\ref{section-method-dataspaces} for details on this method.

\item{\bf ADIOS\_READ\_METHOD\_DIMES} Read from the staging memory of another application using DIMES. The writer applications must use the DIMES transport method when writing. See Section~\ref{section-method-dimes} for details on this method.

\item{\bf ADIOS\_READ\_METHOD\_FLEXPATH} Read from the staging memory of another application using FLEXPATH. The writer applications must use the FLEXPATH transport method when writing. See Section~\ref{section-method-flexpath} for details on this method.

\end{itemize}

Although each read method has a separate initialization, this function can be also used for some global 
settings:

\begin{itemize}
\item{\bf verbose=<integer>} Set the level of verbosity of ADIOS messages: 0=quiet, 1=errors only, 2= warnings, 3=info, 4=debug
\item{\bf quiet} Same as verbose=0
\item{\bf logfile=<path>} Redirect all ADIOS messages to a file. in \adiosversion, there is no process level separation. Note that third-party libraries used by ADIOS will still print their messages to stdout/stderr.
\item{\bf abort\_on\_error} ADIOS will abort the application whenever ADIOS prints an error message. In \adiosversion, there are error messages in some write transport methods that still go to stderr and will not abort the code. 
\end{itemize}

\begin{lstlisting}[alsolanguage=C]

int adios_read_init_method (enum ADIOS_READ_METHOD method, 
                            MPI_Comm comm, 
                            const char * parameters);

\end{lstlisting}

The \verb+adios_config+ tool lists the available read methods in the actual installation when using the -m option.

\begin{lstlisting}
$ adios_config -m
...
Available read methods (constants after #include "adios_read.h"):
    ADIOS_READ_METHOD_BP (=0)
    ADIOS_READ_METHOD_BP_AGGREGATE (=1)
    ADIOS_READ_METHOD_DATASPACES (=3)
    ADIOS_READ_METHOD_FLEXPATH (=5)
...
\end{lstlisting}


\subsection{adios\_read\_finalize\_method}

Finalize the selected method. Required for all methods that are initialized. 
\begin{itemize}
\item{\bf method} Read method to finalize. 
\end{itemize}

\begin{lstlisting}[alsolanguage=C]

int adios_read_finalize_method(enum ADIOS_READ_METHOD method);
\end{lstlisting}


\subsection{adios\_read\_open}
Open an adios file/stream as a stream. In the returned ADIOS\_FILE struct, current\_step is the 
currently opened step, which is the oldest step of the stream still available at the time of open.
Only data in this current step can be read.
The last\_step indicates the newest step, which is available in the staging area. It is only an indicator
to the reader about how far ahead the writer is in data production.  
The number and list of variables in the ADIOS\_FILE struct reflects the variables in the current step only.
The list will change when advancing the step if the writing 
application writes different variables at different times. 

\begin{itemize}
\item{\bf fname}  Pathname of file/stream to be opened.
\item{\bf method}  Read method to use for this particular stream.
\item{\bf comm}    The MPI communicator of all processes that want to read data from the stream.
If compiled with -D\_NOMPI, pass any integer here.
\item{\bf lock\_mode} In case of real streams, a step may need to be locked in memory to be able
to read all data of the step completely. Available options include ADIOS\_LOCKMODE\_NONE, ADIOS\_LOCKMODE\_CURRENT, and ADIOS\_LOCKMODE\_ALL.
\item{\bf timeout\_sec}  $>=0.0$: block until the stream becomes available but 
for max 'timeout\_sec' seconds.\\
$0.0$: return immediately if stream is not available\\
$<0.0$: block possibly forever.\\
Note: $<0.0$ does not ever return with err\_file\_not\_found error, 
which is dangerous if the stream name is simply mistyped in the code.
\end{itemize}

\noindent The function returns a pointer to an ADIOS\_FILE struct on success, NULL on error with setting adios\_errno. 
Possible errors (adios\_errno values)

\begin{itemize}
\item{\bf err\_file\_not\_found\_error}  File/stream does not exist / not yet available.
\item{\bf err\_end\_of\_stream}  Stream has ended, nothing is available and no more steps should be expected.
\end{itemize}


\begin{lstlisting}[alsolanguage=C]
ADIOS_FILE * adios_read_open (const char * fname, 
                              enum ADIOS_READ_METHOD method, 
                              MPI_Comm comm, 
                              enum ADIOS_LOCKMODE lock_mode,
                              float timeout_sec);
\end{lstlisting}

\noindent The returned ADIOS\_FILE structure includes the following information:

\begin{itemize}
\item{\bf int nvars}   Number of variables in the file (with full path)
\item{\bf char ** var\_namelist}   Variable names in a char* array
\item{\bf int nattrs}  Number of attributes in the file
\item{\bf char ** attr\_namelist}  Attribute names in a char* array
\item{\bf int current\_step}  The current step in a stream. For a file, it is always 0. 
\item{\bf int last\_step}     The currently available latest step in the stream/file.  
\end{itemize}


\subsection{adios\_read\_open\_file}

Open an adios file as a file. Each variable can have different number of steps. Arbitrary steps of a variable
can be read at any time.  In the returned ADIOS\_FILE struct, current\_step is always 0, while last\_step is the number of global steps - 1. The list of variables include all variables written in all steps. 

\begin{itemize}
\item{\bf fname}    Pathname of file to be opened.
\item{\bf method}   Read method to use for this particular file.
\item{\bf comm}     The MPI communicator of all processes that want to read data from the file. If compiled with -D\_NOMPI, pass any integer here or use 'mpidummy.h' provided by the ADIOS installation. 
\end{itemize}

The function returns a pointer to an ADIOS\_FILE struct, NULL on error (sets adios\_errno). 

Possible errors (adios\_errno values)
\begin{itemize}
\item{\bf err\_file\_not\_found\_error}  File does not exist. 
\end{itemize}

\begin{lstlisting}[alsolanguage=C]
ADIOS_FILE * adios_read_open_file (const char * fname, 
                                   enum ADIOS_READ_METHOD method,
                                   MPI_Comm comm);
\end{lstlisting}

\subsection{adios\_read\_close}
Close an adios file. It will free the content of the underlying data structures and the fp pointer itself.

\begin{itemize}
\item{\bf fp}    The pointer of the ADIOS\_FILE structure returned by the open function.
\end{itemize}

The function returns 0 on success, $!=0$ on error (also sets adios\_errno).

\begin{lstlisting}[alsolanguage=C]
int adios_read_close (ADIOS_FILE *fp);

\end{lstlisting}

\subsection{adios\_advance\_step}
Advance the current step of a stream. For files opened as file, stepping has no effect.
In case of streams, 

\begin{enumerate}
\item An error should be expected for any step, since a step might not yet be available 

\item One can advance to the next available or to the last (newest) available step only. 
No steps can be hopped over. Nevertheless, one can use the current step's counter to advance 
many times to get to a certain step. 

\item It depends on the locking method, if advancing to the next step advances to the next
immediate step (ADIOS\_LOCKMODE\_ALL) or to the next available step (ADIOS\_LOCKMODE\_CURRENT). 
Still, if the reading method in use does not support locking all steps, advancing to the 'next' step may fail 
if that step is not available anymore and return an error. 

\item Advancing to step N informs the read method that all steps 
before N can be removed if space is needed. There is no way to go back to previous steps.
\end{enumerate}

\noindent Arguments:
\begin{itemize}
\item{\bf fp}       Pointer to an ADIOS\_FILE struct.
\item{\bf last}     $0$: next available step, $!=0$: newest available step 
 \item{\bf timeout\_sec}  $>=0.0$: block until the next step becomes available but 
for max 'timeout\_sec' seconds.\\
$0.0$ means return immediately if step is not available.\\
$<0.0$: block forever if necessary.
\end{itemize}

\noindent The function returns 0 on success, $!=0$ on error (also sets adios\_errno).
Possible errors (adios\_errno values):

\begin{itemize}
\item{\bf err\_end\_of\_stream}    Stream has ended, no more steps should be expected

\item{\bf err\_step\_notready}    The requested step is not yet available.

\item{\bf err\_step\_disappeared} The requested step is not available anymore. This error is possible only if the read method does not support LOCKMODE\_ALL, you open the stream with LOCKMODE\_ALL, request to advance to next and the immediate step after the currently opened one is not available any more, and the method actually returns the error instead of advancing to the next available step. 
\end{itemize}


\begin{lstlisting}[alsolanguage=C]
int adios_advance_step (ADIOS_FILE *fp, int last, float timeout_sec); 
\end{lstlisting}

\subsection{adios\_release\_step}
Release a step in a stream without seeking to the next step.
This function is to inform the read method that the current step is
no longer needed, but the reader does not yet want to read another step.
This function releases the lock on the step only. The current step is not
changed in the ADIOS\_FILE struct, but resources are freed and thus ADIOS function calls other than advancing or closing the file will fail. 

Since \verb+adios_advance_step()+ also releases the step from which one advances 
forward, it is not causing memory leaks if this function is not called. However, it is good practice to release a step after reading all necessary data and before processing it, to let the writer code make progress in the meantime.

\begin{lstlisting}[alsolanguage=C]
void adios_release_step (ADIOS_FILE *fp);
\end{lstlisting}

\subsection{adios\_inq\_var}
\label{section:read_api_adios_inq_var}
Inquires about a variable.
This function does not read anything from the file but processes info
already in memory after fopen.
It allocates memory for the ADIOS\_VARINFO struct and content, so
you need to free resources later with adios\_free\_varinfo().

Note that you can get a scalar variable's value (including strings)
with this operation without touching the file/stream.
The 'stats' element will be NULL after this call. To get the statistics, 
another call must be made after this: adios\_inq\_var\_stat().
The 'blocks' element will be NULL after this call. To get the decomposition
of a variable in the file/stream, another call must be made after this: 
adios\_inq\_var\_blockinfo().

\begin{itemize}
 \item{\bf fp} Pointer to an (opened) ADIOS\_FILE struct.
\item{\bf varname}  Name of the variable.
\end{itemize}

\noindent The function returns a pointer to an ADIOS\_VARINFO struct, NULL on error (sets adios\_errno).

\begin{lstlisting}[alsolanguage=C]
ADIOS_VARINFO * adios_inq_var (ADIOS_FILE *fp, const char * varname);

\end{lstlisting}

\subsection{adios\_inq\_var\_byid}
This function is the same as adios\_inq\_var but uses a numerical index instead of a name to reference the variable. 

\begin{itemize}
\item{\bf varid}    index of variable (0..fp->nvars-1)
in fp->vars\_namelist of ADIOS\_FILE struct
\end{itemize}

\noindent The function returns a pointer to an  ADIOS\_VARINFO struct, NULL on error (sets adios\_errno).

\begin{lstlisting}[alsolanguage=C]
ADIOS_VARINFO * adios_inq_var_byid (ADIOS_FILE *fp, int varid);
\end{lstlisting}

\subsection{adios\_free\_varinfo}
Free memory used by an ADIOS\_VARINFO struct. 
\begin{itemize}
\item{\bf cp} The ADIOS\_VARINFO struct that needs to be free'd. 
\end{itemize}

\noindent The function does not return any value.

\begin{lstlisting}[alsolanguage=C]
void adios_free_varinfo (ADIOS_VARINFO *cp);
\end{lstlisting}

\subsection{adios\_inq\_var\_stat}
Get statistics recorded about a variable. The information to calculate the statistics are recorded in the metadata,
so no extra file access is necessary after adios\_fopen() for this operation.
The result is stored in the ADIOS\_VARSTAT struct under varinfo.stats. 
adios\_free\_varinfo() will free the extra memory allocated in this call. 
Note that the generation of statistics can be turned off at writing, and then this function will deliver 
nothing; it is not going to read the data and calculate the statistics. 

\begin{itemize}
\item{\bf fp}  Pointer to an (opened) ADIOS\_FILE struct.
\item{\bf  varinfo}        Result of adios\_inq\_var(). 
\item{\bf per\_step\_stat}  $!=0$: return statistics also per step
\item{\bf per\_block\_stat} $!=0$: return statistics also per writer block 
\end{itemize}

\noindent The function returns 0 on success, $!=0$ on error (also sets adios\_errno). 

\begin{lstlisting}[alsolanguage=C]
int adios_inq_var_stat (ADIOS_FILE *fp, ADIOS_VARINFO * varinfo,
                        int per_step_stat, int per_block_stat);
\end{lstlisting}

\subsection{adios\_inq\_var\_blockinfo}
Get the block-decomposition of the variable about how it is stored in 
the file or stream. The decomposition information are recorded in the
metadata, so no extra file access is necessary after adios\_fopen() for 
this operation. The result is stored in the array of 
ADIOS\_VARBLOCK structs under varinfo.blocks. 

adios\_free\_varinfo() will free the extra memory allocated in this call.
\begin{itemize} 
\item{\bf fp}       Pointer to an (opened) ADIOS\_FILE struct.
\item{\bf varinfo}  Result of adios\_inq\_var(). 
\end{itemize}
Function returns 0 on success, $!=0$ on error (also sets adios\_errno).

\begin{lstlisting}[alsolanguage=C]
int adios_inq_var_blockinfo (ADIOS_FILE *fp, ADIOS_VARINFO * varinfo);
\end{lstlisting}


%
% Selections
%
\subsection{Selections}
Before reading some data, one needs to create a selection object, unless a variable is to be read in 
as a whole by one process. ADIOS supports 4 types of selections: contigous bounding box, list of 
individual points, the block written separately (by one process), and automatic selection to let the 
method decide what is optimal to deliver to the specific reader. Note that dimensions and number 
of points are all 64bit integers as ADIOS supports large datasets. 

The functions below return a pointer to the ADIOS\_SELECTION struct which can be used to read variables.
 

\subsubsection{adios\_selection\_boundingbox}
A boundingbox selection to read a contiguous subset of a multi-dimensional array.

\begin{itemize} 
\item{\bf ndim}      Number of dimensions
\item{\bf start}     Array of offsets to start reading in each dimension
\item{\bf count}     Number of data elements to read in each dimension
\end{itemize}

\begin{lstlisting}[alsolanguage=C]
ADIOS_SELECTION * adios_selection_boundingbox (uint64_t ndim, 
                                               const uint64_t *start, 
                                               const uint64_t *count);
\end{lstlisting}


\subsubsection{adios\_selection\_points}
Selection of an enumeration of positions.
Each point is described in the N--dimensional (array index) space is 
described by N offsets. The positions should be enumerated in a 1D array,
with the N offsets of each point together.

\begin{itemize} 
\item{\bf ndim}      Number of dimensions
\item{\bf npoints}   Number of points of the selection
\item{\bf points}    1D array of indices, compacted for all dimension
(e.g.  [i1,j1,k1,i2,j2,k2,...,in,jn,kn] for n points in a 3D space.
\end{itemize}

\begin{lstlisting}[alsolanguage=C]
ADIOS_SELECTION* adios_selection_points (uint64_t ndim, 
                                         uint64_t npoints, 
                                         const uint64_t *points);
\end{lstlisting}


\subsubsection{adios\_selection\_writeblock}
Selection for a block of data coming from a certain producer.
A global array consist of many individual, contiguous blocks written out by
many writers. One writer may output multiple subsets of a variable. 
Due to the ADIOS BP format's log-file structure, these blocks are accessible 
separately, and this selection lets users exploit this fact. 

The number of blocks is returned by adios\_inq\_var(). 
Indexing of the blocks starts from 0 for the first block
written by producer rank 0. Blocks from one writer will have consecutive indices. 
If each writer outputs one block then the index equals to the rank of the write process. 
With multi-var writing and multiple steps in a file, the index should be
calculated by the reading application using external information beyond
what is provided by the ADIOS Read API 
(e.g. writing this information out into the file as variables).

This selection replaces the adios\_read\_local\_var() function of the old read API. 
Its main use has been to read files where a variable is not a global array, because 
the application cannot organize the blocks into an N-dimensional contiguous array. 
This is the only way to access all writers' blocks of such 'local' variables.

\begin{itemize} 
\item{\bf index}    Index of the written block
\end{itemize}

\begin{lstlisting}[alsolanguage=C]
ADIOS_SELECTION* adios_selection_writeblock (int index);
\end{lstlisting}


\subsubsection{adios\_selection\_auto}
Let the method decide what data gets to what reader process.
This selection enables each reading method to provide an 'optimal'
data transfer from writers to readers. It depends on the method and the 
circumstances, what this selection actually means.
E.g. intra-node in situ processing: readers on a compute node will receive all data 
from the writers on the same compute node.

\begin{itemize} 
\item{\bf hints}    Method dependent parameters to influence what and how to 
 return (e.g. decomposition; ordering of returned chunks)
\end{itemize} 

\begin{lstlisting}[alsolanguage=C]
ADIOS_SELECTION* adios_selection_auto (char * hints);
\end{lstlisting}


\subsubsection{adios\_selection\_delete}
Delete a selection and free up memory used by the selection.

\begin{lstlisting}[alsolanguage=C]
void adios_selection_delete (ADIOS_SELECTION *selection);
\end{lstlisting}




\subsection{adios\_schedule\_read}
Schedule reading a (subset of a) variable from the file.
In most cases, you need to allocate the memory for the data and 
Call adios\_perform\_reads() to 
complete the reading of the variables. Multiple reads can/should be scheduled before performing 
all of them at once. This strategy can improve the use of available I/O bandwidth and possible avoid
some seeking on disks. Nevertheless, multiple schedule/perform cycles can be executed on an 
open file/steam.

In blocking read mode, the memory should be pre-allocated. 
In non-blocking mode, memory can be allocated or not, and that changes the behavior of the chunked read. 
If memory is allocated, adios\_check\_read() returns the whole requested subset of a variable when it is completed.
If memory is not allocated, the check returns any chunk already available of a variable (in ADIOS own buffer)
and the application has to rearrange the data. The user has to process/copy the data before getting new chunks.

\begin{itemize}
\item{\bf  fp}         Pointer to an (opened) ADIOS\_FILE struct.
\item{\bf  sel}        Selection created beforehand with adios\_selection...().
                 sel=NULL means global selection (whole variable)
\item{\bf  varname}    Name of the variable.
\item{\bf  from\_step}  File mode only: Read the 'nsteps' consecutive steps from this 
step of a file variable, instead of from the current (global) step of the file. It is not used in case of a stream.
\item{\bf nsteps}     Read 'nsteps' consecutive steps from current step. Must be 1 for a stream. 
\item{\bf data} Pointer to the memory to hold data of the variable. NULL in case of non-blocking, chunked reading.
\end{itemize}

The function returns 0 on success, $!=0$ on error (also sets adios\_errno).

\begin{lstlisting}[alsolanguage=C]
int adios_schedule_read (const ADIOS_FILE * fp,
                         const ADIOS_SELECTION * sel,
                         const char            * varname,
                         int                     from_steps,
                         int                     nsteps,
                         void                  * data);
\end{lstlisting}



\subsection{adios\_schedule\_read\_byid}
This function is the same as adios\_schedule\_read but uses a numerical index instead of a name to reference the variable. 

\begin{itemize}
\item{\bf varid} Index of variable (0..fp->nvars-1) in fp->var\_namelist of ADIOS\_FILE struct. 
\end{itemize}

\begin{lstlisting}[alsolanguage=C]
int adios_schedule_read_byid (const ADIOS_FILE * fp, 
                              const ADIOS_SELECTION * sel,
                              int                     varid,
                              int                     from_steps,
                              int                     nsteps,
                              void                  * data);
\end{lstlisting}



\subsection{adios\_perform\_reads}
Once adios\_schedule\_read command has been issued for all the variables needed by the reading application, the adios\_perform\_reads 
is called to start performing the reads. 
\begin{itemize}
\item{\bf blocking} If non-zero, return only when all reads are completed.
If zero, return immediately and report partial completions
through adios\_check\_reads(). 
\end{itemize}

\begin{lstlisting}[alsolanguage=C]
int adios_perform_reads (const ADIOS_FILE *fp, int blocking);
\end{lstlisting}



\subsection{adios\_check\_reads}
Get a chunk of completed read(s) in a non-blocking or in a non-blocking+chunking read scenario.
This function should be called in a loop until all chunks are processed. 
That is indicated by a 0 return value. A NULL result for chunk only
indicates that no chunk is available at the time of call. 

One chunk is returned at a time. If memory for a variable is provided in adios\_schedule\_read 
(non-blocking scenario), one chunk will be returned for the variable, and the memory will be 
fully organized (contiguous block). If memory is not provided by the user,  a selection of an array 
specified in a read may be completed in multiple chunks (usually when they come from 
multiple sources, like different disks or different application processes). 

\begin{itemize}
\item{\bf fp} Handler to file or stream.
\item{\bf chunk} A chunk completed by the time of calling this function.
It is NULL if no chunk is returned.
\end{itemize}
This function returns 
\begin{itemize}
\item $0$: All chunks have been returned previously, 
                no need to call again (chunk is NULL, too).
\item $1$: Some chunks are/will be available, call again. 
\item $<0$: On error (also sets adios\_errno).
\end{itemize}

\begin{lstlisting}[alsolanguage=C]
int adios_check_reads (const ADIOS_FILE  * fp, 
                       ADIOS_VARCHUNK   ** chunk);
\end{lstlisting}

\subsection{adios\_free\_chunk}
Free the memory of a chunk allocated inside adios\_check\_reads().
It only frees the ADIOS\_VARCHUNK struct and the ADIOS\_SELECTION struct
pointed by the chunk. The data pointer should never be freed since
that memory belongs to the reading method.

\begin{lstlisting}[alsolanguage=C]
void adios_free_chunk (ADIOS_VARCHUNK *chunk);
\end{lstlisting}



\subsection{adios\_get\_attr}
Get an attribute in a file.
This function does not read anything from the file but processes info
already in memory after fopen.
The memory for the data is allocated within the library.
You can use free() to free the memory after use.

\begin{itemize}
\item{\bf fp}       Pointer to an (opened) ADIOS\_FILE struct.
\item{\bf attrname} Name of the attribute.
\item{\bf type}    ADIOS type of attribute (see enum ADIOS\_DATATYPES in adios\_types.h) filled in by the call. 
\item{\bf size}     Memory size of value (n+1 for a string of n characters) filled in by the call. 
\item{\bf data}    Pointer to the value filled in by the call. You need to cast it afterward according to the type.
\end{itemize}

Function returns 0 on success, $!=0$ on error (also sets adios\_errno).

\begin{lstlisting}[alsolanguage=C]
int adios_get_attr (ADIOS_FILE            * fp,
                    const char            * attrname,
                    enum ADIOS_DATATYPES  * type,
                    int                   * size,
                    void                 ** data);

\end{lstlisting}



\subsection{adios\_get\_attr\_byid}
This function is the same as adios\_get\_attr but uses a numerical index instead of a name to reference the variable. 
\begin{itemize}
\item{\bf attrid} Index of attribute (0..fp->nattrs-1) in fp->attr\_namelist of ADIOS\_FILE struct. 
\end{itemize}
\begin{lstlisting}[alsolanguage=C]
int adios_get_attr_byid (ADIOS_FILE            * fp, 
                         int                    attrid,  
                         enum ADIOS_DATATYPES  * type,
                         int                   * size, 
                         void                 ** data);
\end{lstlisting}



\subsection{adios\_type\_to\_string}
 Return the name of an adios type. 

\begin{lstlisting}[alsolanguage=C]
const char * adios_type_to_string (enum ADIOS_DATATYPES type);
\end{lstlisting}


\subsection{adios\_type\_size}
Return the memory size of one data element of an adios type.
If the type is adios\_string, and the second argument is
the string itself, it returns strlen(data)+1. 
For other types, it does not care about data and returns
the size occupied by one element.

\begin{lstlisting}[alsolanguage=C]
int adios_type_size(enum ADIOS_DATATYPES type, 
                    void *data);
\end{lstlisting}


\subsection{adios\_get\_grouplist}
Return the list of groups (names) that are written into
the file. There is always at least one group there.

\begin{itemize}
\item{\bf fp} Pointer to an (opened) ADIOS\_FILE struct
\item{\bf group\_namelist} List of strings. This list is created and filled in by the function call. It should be freed by the user when it is not needed anymore.
\end{itemize}

Function returns the number of groups, $<0$ on error (also sets adios\_errno).

\begin{lstlisting}[alsolanguage=C]
int adios_get_grouplist (ADIOS_FILE  *fp, 
                         char ***group_namelist);
\end{lstlisting}


\subsection{adios\_group\_view}
Restrict the view of variables/attributes to a certain group.
The provided ADIOS\_FILE structure is directly modified but
another calls can change to a different group view, or reset
back to full view.

\begin{itemize}
\item{\bf groupid} Id of the selected group (0..\# of groups-1) use -1 to reset to the complete list.
\item{\bf fp} Pointer to an (opened) ADIOS\_FILE struct nvars, var\_namelist, nattrs, and attr\_namelist will be modified.
\end{itemize}

Function returns 0 on success, $!=0$ on error (also sets adios\_errno).

Note: A stream does not have groups, only a file can have multiple groups 
(from separate adios\_open/adios\_close operations). 

\begin{lstlisting}[alsolanguage=C]
int adios_group_view (ADIOS_FILE  *fp, 
                      int groupid);
\end{lstlisting}


\section{Time series analysis API Description}

ADIOS provides APIs to perform time-series analysis like correlation and covariance 
on statistics collected in the BP file. As described in 
Section \ref{section:read_api_adios_inq_var}, the \verb+adios_inq_var+ and 
\verb+adios_inq_var_stat+ functions
populate characteristics, such as minimum, maximum, average, standard deviation 
values for an array for each timestep. The following analysis function can be used 
with \verb+ADIOS_VARINFO+ objects previously defined. This can be performed only for 
a variable that has a time index.

\subsection{adios\_stat\_cor / adios\_stat\_cov}

This function calculates Pearson correlation/covariance of the characteristic data 
of \textit{vix} and characteristic data of \textit{viy}.

\begin{lstlisting}[]
double adios_stat_cor (ADIOS_VARINFO * vix, 
    ADIOS_VARINFO                    * viy, 
    char                  * characteristic, 
    uint32_t                    time_start, 
    uint32_t                      time_end, 
    uint32_t                           lag)

double adios_stat_cov (ADIOS_VARINFO * vix, 
    ADIOS_VARINFO                    * viy, 
    char                  * characteristic, 
    uint32_t                   time_start, 
    uint32_t                     time_end, 
    uint32_t                          lag)
\end{lstlisting}

Required:

\begin{itemize}
\item vix - an ADIOS\_VARINFO object
\end{itemize}

Optional:

\begin{itemize}
\item viy - either an ADIOS\_VARINFO object or NULL 

\item characteristics - can be any of the following pre-computed 
statistics: \texttt{"}minimum\texttt{"} or \texttt{"}maximum\texttt{"} or \texttt{"}average\texttt{"} 
or \texttt{"}standard deviation\texttt{"} (alternatively, \texttt{"}min\texttt{"} 
or \texttt{"}max\texttt{"} or \texttt{"}avg\texttt{"} or \texttt{"}std\_dev\texttt{"} 
can be given)

\item time\_start - specifies the start time from which correlation/covariance 
should be performed

\item time\_end - specifies the end time up to which correlation/covariance 
should be performed

time\_start and time\_end should be within the time bounds of vix and viy with 
time\_start \texttt{<} time\_end

If time\_start and time\_end = 0, the entire range of timesteps is considered. 
In this case, vix and viy should have the same number of timesteps.

\item lag - if viy is NULL, and if lag is given, correlation is performed 
between the data specified by vix, and vix shifted by 'lag' timesteps.  If viy 
is not NULL, lag is ignored.
\end{itemize}


\section{Read Fortran API description}
\label{section:read_fortran_api}

The Fortran API does not deal with the structures of the C api rather it requires 
several arguments in the function calls.  They are all implemented as subroutines 
like the write Fortran API and the last argument is an integer variable to store 
the error code output of each function (0 meaning successful operation). 

A Fortran90 module, \verb+adios_read_mod.mod+ provides the available ADIOS subroutines. 
An example code can be found in the source distribution as 
\verb+tests/bp_read/bp_read_f.F90+.

The most important thing to note is that some functions need integer*8 (scalar 
or array) arguments. Passing an integer*4 array from your code leads to fatal errors. 
Please, double check the arguments of the function calls. 

In contrast to the C API, where the open function returns a structure filled with 
a lot of information, the Fortran API only returns a handle. Therefore, 
you have to inquiry the file after opening it.
You also have to inquiry an attribute to determine the memory 
size needed to store its value and allocate space for it before retrieving it. 

Where the API function returns a list of names (inquiry file or inquiry group), 
you have to provide enough space for them using the counts returned by the preceding 
open call. 

From functionality point of view, the difference in C and Fortran is that the 
Fortran API does not allow non-blocking reads in \verb+adios_perform_reads+, and thus
chunking is not working either. Memory for all variables should be allocated in advance 
to store the data.

Here is the list of the Fortran90 subroutines from \verb+adios_read_mod.mod+. 
In the list below \verb+GENERIC+ word indicates that you 
can use that function with any data type at the indicated argument; it is not
a Fortran90 keyword. The actual module source defines all possible combinations 
of type and dimensionality for such subroutines. 

\begin{lstlisting}[language=ADIOS,alsolanguage=Fortran]
subroutine adios_errmsg (msg)
    character(*),   intent(out) :: msg
end subroutine

subroutine adios_read_init_method (method, comm, parameters, err)
    integer,        intent(in)  :: method
    integer,        intent(in)  :: comm
    character(*),   intent(in)  :: parameters
    integer,        intent(out) :: err
end subroutine

subroutine adios_read_finalize_method (method, err)
    integer,        intent(in)  :: method
    integer,        intent(out) :: err
end subroutine

subroutine adios_read_open (fp, fname, method, comm, lockmode, 
                            timeout_sec, err)
    integer*8,      intent(out) :: fp
    character(*),   intent(in)  :: fname
    integer,        intent(in)  :: method
    integer,        intent(in)  :: comm
    integer,        intent(in)  :: lockmode
    real,           intent(in)  :: timeout_sec
    integer,        intent(out) :: err
end subroutine

subroutine adios_read_open_file (fp, fname, method, comm, err)
    integer*8,      intent(out) :: fp
    character(*),   intent(in)  :: fname
    integer,        intent(in)  :: method
    integer,        intent(in)  :: comm
    integer,        intent(out) :: err
end subroutine

subroutine adios_advance_step (fp, last, timeout_sec, err)
    implicit none
    integer*8,      intent(in)  :: fp
    integer,        intent(in)  :: last
    real,           intent(in)  :: timeout_sec
    integer,        intent(out) :: err
end subroutine

subroutine adios_release_step (fp, err)
    implicit none
    integer*8,      intent(in)  :: fp
    integer,        intent(out) :: err
end subroutine

subroutine adios_read_close (fp, err)
    integer*8,      intent(in)  :: fp
    integer,        intent(out) :: err
end subroutine

subroutine adios_inq_file (fp, vars_count, attrs_count, 
                           current_step, last_step, err)
    integer*8,      intent(in)  :: fp
    integer,        intent(out) :: vars_count
    integer,        intent(out) :: attrs_count
    integer,        intent(out) :: current_step
    integer,        intent(out) :: last_step
    integer,        intent(out) :: err
end subroutine

subroutine adios_inq_varnames (fp, vnamelist, err)
    integer*8,      intent(in)  :: fp
    character(*), dimension(*), intent(inout) :: vnamelist
    integer,        intent(out) :: err
end subroutine

subroutine adios_inq_attrnames (fp, anamelist, err)
    integer*8,      intent(in)  :: fp
    character(*), dimension(*), intent(inout) :: anamelist
    integer,        intent(out) :: err
end subroutine

subroutine adios_inq_var (fp, varname, vartype, nsteps, ndim, dims, err)
    integer*8,      intent(in)  :: fp
    character(*),   intent(in)  :: varname
    integer,        intent(out) :: vartype
    integer,        intent(out) :: nsteps
    integer,        intent(out) :: ndim
    integer*8, dimension(*), intent(out) :: dims
    integer,        intent(out) :: err
end subroutine

subroutine adios_inq_attr (fp, attrname, attrtype, attrsize, err)
    integer*8,      intent(in) :: fp
    character(*),   intent(in)  :: attrname
    integer,        intent(out) :: attrtype
    integer,        intent(out) :: attrsize
    integer,        intent(out) :: err
end subroutine

subroutine adios_get_scalar (fp, varname, data, err)
    integer*8,      intent(in)  :: fp
    character(*),   intent(in)  :: varname
    GENERIC,        intent(out) :: data
    integer,        intent(out) :: err
end subroutine

subroutine adios_selection_boundingbox (sel, ndim, start, count)
    integer*8,      intent(out)          :: sel
    integer,        intent(in)           :: ndim
    integer*8, dimension(*), intent(in)  :: start
    integer*8, dimension(*), intent(in)  :: count
end subroutine

subroutine adios_selection_points (sel, ndim, npoints, points)
    integer*8,      intent(out)          :: sel
    integer,        intent(in)           :: ndim
    integer*8,      intent(in)           :: npoints
    integer*8, dimension(*), intent(in)  :: points
end subroutine

subroutine adios_selection_writeblock (sel, index)
    integer*8,      intent(out)          :: sel
    integer,        intent(in)           :: index
end subroutine

subroutine adios_selection_auto (sel, hints)
    integer*8,      intent(out)          :: sel
    character(*),   intent(in)           :: hints
end subroutine

subroutine adios_selection_delete (sel)
    integer*8,      intent(in)           :: sel
end subroutine

subroutine adios_schedule_read (fp, sel, varname, from_step, nsteps, data, err)
    integer*8,      intent(in)  :: fp
    integer*8,      intent(in)  :: sel
    character(*),   intent(in)  :: varname
    integer,        intent(in)  :: from_step
    integer,        intent(in)  :: nsteps
    GENERIC, GENERIC_DIMENSIONS, intent(inout) :: data
    integer,        intent(in)  :: err
end subroutine

subroutine adios_perform_reads (fp, err)
    integer*8,      intent(in)  :: fp
    integer,        intent(out) :: err
end subroutine

subroutine adios_get_attr (gp, attrname, attr, err)
    integer*8,      intent(in)  :: gp
    character(*),   intent(in)  :: attrname
    GENERIC,        intent(inout) :: attr
    integer,        intent(out) :: err
end subroutine

subroutine adios_get_statistics (gp, varname, value, gmin, gmax, gavg, 
                                 gstd_dev, mins, maxs, avgs, std_devs, err)
    integer*8,      intent(in)  :: gp
    character(*),   intent(in)  :: varname
    GENERIC,        intent(out) :: value
    GENERIC,        intent(out) :: gmin
    GENERIC,        intent(out) :: gmax
    real*8,         intent(out) :: gavg
    real*8,         intent(out) :: gstd_dev
    GENERIC, dimension(*), intent(inout) :: mins
    GENERIC, dimension(*), intent(inout) :: maxs
    real*8, dimension(*), intent(inout) :: avgs
    real*8, dimension(*), intent(out) :: std_devs
    integer,dimension(*), intent(out) :: err
end subroutine

!
! Group operations for the case when a file has multiple groups and 
! one really wants to see only one of them at a time
!
subroutine adios_inq_ngroups (fp, groups_count, err)
    integer*8,      intent(in)  :: fp
    integer,        intent(out) :: groups_count
    integer,        intent(out) :: err
end subroutine

subroutine adios_inq_groupnames (fp, gnamelist, err)
    integer*8,      intent(in)  :: fp
    character(*), dimension(*), intent(inout) :: gnamelist
    integer,        intent(out) :: err
end subroutine

subroutine adios_group_view (fp, groupid, err)
    integer*8,      intent(in)  :: fp
    integer,        intent(in)  :: groupid
    integer,        intent(out) :: err
end subroutine

\end{lstlisting}

%
%  Schema reading
%
\section{Read Schema API description}
Please consult the \verb+adios_schema.h+ and \verb+adios_read_v2.h+ for the data structures and functions discussed here. In the source code, do not include these header files directly, but include \verb+adios_read.h+. The sequence of reading in a mesh from the BP file is

\begin{itemize}
\renewcommand{\labelitemi}{$-$}
\item initialize the reading method (once per program run)

\item open file/stream  -- this also provides the name of meshes defined in the file

\item inquiry a mesh by meshid to get related mesh structure information

\item free meshinfo data structure

\item close file

\item finalize the read method (once per program run)
\end{itemize}

\subsection{adios\_inq\_mesh\_byid}

\noindent Inquires about a mesh. This function does not read anything from the file but processes info already in memory after fopen. It allocates memory for the ADIOS\_MESH struct and content, so you need to free resources later with adios\_free\_meshinfo().

\begin{itemize}
\item{\bf fp} Pointer to an (opened) ADIOS\_FILE struct.
\item{\bf meshid}    index of mesh (0..fp->nmeshes-1)
in fp->mesh\_namelist of ADIOS\_FILE struct
\end{itemize}

\noindent The function returns a pointer to an ADIOS\_MESHINFO struct or NULL on error. 

\begin{lstlisting}
ADIOS_MESH * adios_inq_mesh_byid (ADIOS_FILE *fp, int meshid)
\end{lstlisting}

\subsection{adios\_free\_meshinfo}

\noindent Free memory used by an ADIOS\_MESH struct.

\begin{itemize}
\item{\bf meshinfo} The ADIOS\_MESH struct that needs to be free'd.
\end{itemize}

\noindent The function does not return any value.

\begin{lstlisting}
void adios_free_meshinfo (ADIOS_MESH *meshinfo)
\end{lstlisting}

\subsection{adios\_inq\_var\_meshinfo}

\noindent Get the mesh for a given variable. One must call \verb+adios_inq_var()+ first to have the \verb+ADIOS_VARINFO+ struct. This call will fill out the \verb+struct ADIOS_VARMESH *meshinfo+ struct in that struct.
This simple struct contains the mesh id, and a flag indicating if the centering of the data on the mesh (node centered or cell centered).

\noindent The function returns 0 on success, and and non-zero on error.

\begin{lstlisting}
int adios_inq_var_meshinfo (ADIOS_FILE *fp, ADIOS_VARINFO * varinfo);
\end{lstlisting}
%
%
%
\section{Compiling and linking applications}

You are encouraged to use the utility \verb+adios_config+ to get the compile and link options for your 
need, using -f option to get the Fortran options, -c for compile, -l for linking, 
-s for non-MPI applications (see Section \ref{section:installation_compiling_apps}). 


\subsection{C/C++ applications}

In a C code, include the \verb+adios_read.h+ header file.  

\begin{itemize}
\item If you want to use the MPI version of the library, then link your application with \verb+-ladiosread+.

\item If you want to use the non-MPI version of the library, you need to compile your 
code with the \verb+-D_NOMPI+ option and link your application with \verb+-ladiosread_nompi+.

\item If you have a code using the old (before ADIOS 1.4) read API, compile your code with the

\verb+-DADIOS_USE_READ_API_1+ and link your application with one of the two libraries above.

\end{itemize}

\subsection{Fortran applications}

In a Fortran 90 code,  use the module 
\verb+adios_read_mod+. It is strongly recommended to use it to double check the integer 
parameters because the read API expects \verb+integer*8+ arguments 
at several places and providing an integer will break your code and then debugging 
it proves to be very difficult.

\begin{itemize}
\item If you want to use the MPI version of the library, then link your  application with \verb+-ladiosreadf+.

\item If you want to use the non-MPI version of the library, you need to compile your 
code with the \verb+-D_NOMPI+ option and link your application with \verb+-ladiosreadf_nompi+.

\item If you have a code using the old (before ADIOS 1.4) read API,  
do not use the adios\_read\_mod module and link your application 
with one of the two libraries 

\verb+-ladiosreadf_v1+ or \verb+-ladiosreadf_nompi_v1+.

\end{itemize}




\section{Supported scenarios and samples}

For all C examples below the following variables are assumed to be defined:
\begin{lstlisting}[frame=none]
MPI_Comm comm;     // group communicator
ADIOS_FILE *fp;    // file handler
ADIOS_VARINFO *vi; // information about one variable
double *P;         // array to store variable "P"
\end{lstlisting}


\section{Reading a file as file}
If a file is opened as a "file" (and not as a stream) than the followings are true:

  \begin{itemize}
  \item All steps in the file are available for reading; there is no "current step" from which to read and therefore, there is no need to advance the step.
  \item Variables have their own counter for steps. Different variables can have different steps available.
  \item Multiple consecutive steps of a variable can be read at once, starting from an arbitrary step.
  \item Multiple groups are allowed to exist in the file. The variables of those groups are presented in one list. This leads to the different number of steps of variables.
  \end{itemize}


\subsection{Discover and read in a complete variable}
Assume we have a file called \verb+mydata.bp+ and a 3D array variable \verb+P+ of double type in it. We open the file, determine the size of the array, allocate memory for it and then read it in a blocking way. After \verb+adios_perform_reads()+,  the data is going to be stored in the allocated memory:

\begin{lstlisting}[numbers=left, numberstyle=\color{gray}, stepnumber=2,
                             caption={Read a complete array from a file}, label=code:file_read_var]
fp = adios_read_open_file ("myfile.bp", ADIOS_READ_METHOD_BP, comm);
vi = adios_inq_var (fp, "P");
// vi->ndim tells the number of dimensions
P = (double*) malloc (sizeof(double) * 
                           vi->dims[0] * vi->dims[1] * vi->dims[2]);
adios_schedule_read (fp, NULL, "P", 0, 1, P);
adios_perform_reads (fp, 1);   
// P contains the data at this point
...
// free ADIOS resources
adios_free_varinfo (vi); 
adios_read_close (fp);
\end{lstlisting}


\subsection{Multiple steps of a variable}
 If the file contains more than one step, the array P can have multiple steps too. In case of files, each variable has its own number of steps, provided by \verb+adios_inq_var()+, in the \verb+nsteps+ field of the \verb+ADIOS_VARINFO+ struct. The example in \lstlistingname~\ref{code:file_read_var} still works but only reads in the first step of P. To read all steps at once, we have to allocate a big enough array for it, and request a read for all steps:

\begin{lstlisting}[frame=no, emph={nsteps}, emphstyle={\color{red}\large\bf},
                             numbers=left, numberstyle=\color{gray}, stepnumber=2,firstnumber=3]
...
// vi->nsteps tells the number of steps
P = (double*) malloc (sizeof(double) * 
               vi->nsteps * vi->dims[0] * vi->dims[1] * vi->dims[2]);
adios_schedule_read (fp, NULL, "P", 0, vi->nsteps, P);
...
\end{lstlisting}


\subsection{Read a bounding box subset of a variable}
In parallel codes, a process usually wants to read only a subset of the whole array. If we want to read a rectangular subset from the array, we have to create a boundingbox selection first with \verb+adios_query_boundingbox()+, then pass it as an argument at reading. Let's read a 10x10x10 box from the offset (5,5,5). 


\begin{lstlisting}[numbers=none,
                             caption={Read a bounding box of a variable},  label=code:boundingbox]
fp = adios_read_open_file ("myfile.bp", ADIOS_READ_METHOD_BP, comm);
vi = adios_inq_var (fp, "P");
uint64_t count[] = {10,10,10};
uint64_t offs[] = {5,5,5};
P = (double*) malloc (sizeof(double) * count[0] * count[1] * count[2]);
ADIOS_SELECTION *s = adios_selection_boundingbox (3, offs, count);
adios_schedule_read (fp, s, "P", 0, 1, P);
adios_perform_reads (fp, 1);   
// P contains the data at this point
...
// free ADIOS resources
adios_free_varinfo (vi); 
adios_selection_delete (s); 
adios_read_close (fp);
\end{lstlisting}


\subsection{Reading non-global variables written by multiple processes}
\label {section:non_global_vars}
ADIOS allows for writing an array from several processes with different sizes, that does not constitute a global array view for reading. A reader still has access to each array in the file although they are named the same. \verb+adios_inq_var()+ returns the number of blocks and a flag whether the variable has a global view in the \verb+ADIOS_VARINFO+ struct. If each process writes only one block of the variable, the MPI rank of the writing process identifies each block.  If multiple steps are stored in a file, the second step's indexing starts from 0 again. For stream reading, of course, in each step the block numbering starts from 0. In the most complicated scenario, writers may output multiple blocks per process. In this case, the numbering is continuous for each process, i.e., writer with rank 0 produces block 0, 1, ..., and rank 1 produces the next blocks. 

 A special query is supported for this kind of reading, which selects one of the writing processes:

\begin{lstlisting}[frame=none]
ADIOS_SELECTION *s = adios_selection_writeblock(5);  // read block 5 
\end{lstlisting}
 
This special query still allows the Reader for providing an allocated memory to use blocking read. Usually, applications that read checkpoint files, know the size of each piece in advance from their own configuration file. If not, one can get the size of each block by calling \verb+adios_inq_var()+ and then \verb+adios_inq_var_blockinfo()+. Another way is to read the scalar variables that defined the array size in the writer, using this writeblock selection and use those values. Note that \verb+adios_inq_var()+ provides a scalar variable's value written by one of the writer processes only, so it cannot be used here. To get the scalar value written by a specific process, this rank selection and \verb+adios_schedule_read()+ should be used.

\begin{lstlisting}[numbers=none, 
                   caption={Read an array written by one specific process, with first reading the scalars that define the size of the array},  
                   label=code:localread]
/* first read the scalars that define the size of the array written
    by a given process */
int lx, ly, lz;
adios_schedule_read (fp, s, "lx", 0, 1, &lx);
adios_schedule_read (fp, s, "ly", 0, 1, &ly);
adios_schedule_read (fp, s, "lz", 0, 1, &lz);
adios_perform_reads (fp, 1); 
// allocate memory to read in the array
P = (double*) malloc (sizeof(double) * lx * ly * lz);
adios_schedule_read (fp, s, "P", 0, 1, P);
adios_perform_reads (fp, 1);  
\end{lstlisting}


\begin{lstlisting}[numbers=none, 
                   frame=T,
                   caption={Read an array written by one specific process, with first checking the size},  
                   label=code:localread2]
/* first inquire the variable to check the size of the array written
    by a given process */
int lx, ly, lz;
ADIOS_VARINFO * vi = adios_inq_var (fp, "P");
// vi->nblocks[0] tells us how many write blocks are there
// now get per-block size information
adios_inq_var_blockinfo (fp, vi);
lx = vi->blockinfo[5].count[0]; // 5 is block index here
ly = vi->blockinfo[5].count[1];
lz = vi->blockinfo[5].count[2];
// allocate memory to read in the array
P = (double*) malloc (sizeof(double) * lx * ly * lz);
adios_schedule_read (fp, s, "P", 0, 1, P);
adios_perform_reads (fp, 1);  
\end{lstlisting}

\begin{lstlisting}[numbers=none, 
                   frame=T,
                   caption={Read an array written by one specific process, when multiple steps are in a file},  
                   label=code:localread3]
int step = 3; // read step 3 (steps start from 0)
int block = 5; // read block 5 from step 3 (blocks start from 0)
ADIOS_SELECTION *s = adios_selection_writeblock(`\color{red}{\bf block}`); 
/* first inquire the variable to check the size of the array written
    by a given process */
int lx, ly, lz;
ADIOS_VARINFO * vi = adios_inq_var (fp, "P");
// vi->nblocks[] tells us how many write blocks are there per step
// vi->sum_nblocks is the total number of blocks for all steps
// now get per-block size information
adios_inq_var_blockinfo (fp, vi);
int i, gblock =  block; // gblock to hold global block index
for (i=0; i<step; i++)
    gblock += vi->nblocks[i];
lx = vi->blockinfo[gblock].count[0];
ly = vi->blockinfo[gblock].count[1];
lz = vi->blockinfo[gblock].count[2];
// allocate memory to read in the array
P = (double*) malloc (sizeof(double) * lx * ly * lz);
adios_schedule_read (fp, s, "P", `\color{red}{\bf step}`, 1, P);
adios_perform_reads (fp, 1);  
\end{lstlisting}


\noindent Of course, a global variable can be read this way, too. A global variable in ADIOS is nothing else than the collection of these individual pieces where metadata is available to tell ADIOS the global dimensions and the offsets of these pieces.




%   Stream examples

\section{Reading streams}
A file on disk (containing multiple steps) or a stream provided by a staging method can be opened as a stream. In contrast to files opened as files, the following rules apply here:

  \begin{itemize}
  \item Only one step is accessible.
  \item To read another step, one has to "advance" the step in the stream.
  \item There is no moving back in the stream, only forward.
  \item The file open or the advance operations can fail if data is not available any more.
  \item The end of a stream (last step consumed) is signaled by a different error return value.
  \end{itemize}

The basic read structure is to open a stream, read the first step then advance the step until an error (\verb+err_end_of_stream+) says there is not going to be any more steps. Also, at each advancement, an error may occur if the next step is not available yet (\verb+err_step_notready+) or anymore (\verb+err_step_disappeared+).


\subsection{Opening a stream}
The opening of a stream has to be repeated in case the stream is not yet available. Note, that there is no distinction of the situations where a stream is not yet available vs. the named stream will never exist.

\begin{lstlisting}[numbers=left, numberstyle=\color{gray}, stepnumber=2,
                   caption={While loop to open a stream},  label=code:open_stream]
fp = adios_read_open ("myfile.bp", ADIOS_READ_METHOD_BP, comm, 
                      ADIOS_LOCKMODE_CURRENT, timeout_sec);
while (adios_errno == err_file_not_found) {
    fprintf (stderr, "rank %d: Wait on stream: %s\n", rank, adios_errmsg());
    sleep(1);
    fp = adios_read_open ("myfile.bp", comm, 
                          ADIOS_LOCKMODE_CURRENT, timeout_sec);
}
if (adios_errno == err_end_of_stream) {
    // stream has been gone before we tried to open
    fprintf (stderr, "rank %d: Stream terminated before open. %s\n",
           rank, adios_errmsg());
} else if (fp == NULL) {
    // some other error happened
    fprintf (stderr, "rank %d: Error at opening: %s\n",
           rank, adios_errmsg());

} else {
    // process steps here... see `\color{javagreen}{\lstlistingname~\ref{code:stream_stepbystep}}`
    ...
}
adios_read_close (fp);
\end{lstlisting}


\subsection{Reading one step at a time, blocking if a new step is late}
In the conditional branch of \lstlistingname~\ref{code:open_stream} from line 17 is where we can read steps in a loop. Let's assume we read variable P, of which we already know the size and we have allocated the memory before.

\begin{lstlisting}[numbers=left, numberstyle=\color{gray}, stepnumber=2,firstnumber=18,
                             caption={Read a bounding box of a variable},  label=code:stream_stepbystep]
while (adios_errno != err_end_of_stream) {
    // fp->current_step  contains the step we are at
    adios_schedule_read (fp, NULL, "P", 0, 1, P);
    adios_perform_reads (fp, 1);   
    // this step is no longer needed 
    adios_release_step (fp); 
    // ... process P, then advance the step
    // 1) to the next available step (arg 0 as false) 
    // 2) with blocking wait (-1 as timeout)
    adios_advance_step (fp, 0, -1);
}
\end{lstlisting}

\noindent In the above code snippet we advance to the next available step (second argument in \verb+adios_advance_step()+), possibly skipping other steps if they have appeared and disappeared while we were processing (we asked for locking of only the current step when opening the file). Also we let ADIOS block until a new step becomes available or the stream ends (third parameter in \verb+adios_advance_step()+ equals 1). The \verb+fp->current_step+ informs us of the step we advanced to.


\subsection{Locking and step advancing scenarios}
  \begin{enumerate}  
  \item ADIOS\_LOCKMODE\_ALL + next step: Read all steps one by one, ensure they are not lost. 
  \item ADIOS\_LOCKMODE\_CURRENT + next step: Read each step which is available. 
  \item last step: Read always the last (newest) step available.
  \item ADIOS\_LOCKMODE\_NONE: reader assumes nothing, even current step can disappear between reads.
  \end{enumerate}

If the reader needs to ensure it can process all steps without skipping any, it has to use the strictest locking mode: \verb+ADIOS_LOCKMODE_ALL+, which gives priority to the reader over the performance of the writer. No step will be removed to make space for incoming steps until the reader advances from that step. This may block the writer, so use it only if really needed. Also, when advancing we should ask for the next, and not for the last, step. 

If we ask for the last available step, there is no point of locking all steps and thus potentially slowing down the writer. 

If we lock nothing at read, the current step can be removed by a staging method if the writer has new data. It is the reader's responsibility to handle errors and ensure its consistent state. 

\subsection{Handling errors due to missing steps}
The \verb+adios_advance_step()+ gets the next or last available step. In all cases, the \verb+fp->current_step+ informs us about the new step. One has to save the previous value and compare with the new one to check if some steps were skipped. This function returns two possible errors. If the writer has terminated the stream and the reader is already at the very last step, an \verb+err_end_of_stream+ error will be the result of advancing. This condition should be used to determine when to stop processing the stream. The reader still needs to call \verb+adios_read_close()+ to free up resources. On the other hand, if the reader is at the currently latest step and the staging method has not yet received a newer step from the writer, and we try to advance without blocking, an \verb+err_step_notready+ error will be returned.  



% Non-blocking reads

\section{Non-blocking reads}

\subsection{Chunk reads: read without pre-allocating buffers}
\emph{Note that this chunked read is partially implemented in \adiosversion: memory limits are not considered and each scheduled read is returned in one chunk.}

An ADIOS read method can deliver the data in chunks, in its own working memory. 
The application has to process that data before checking for new chunks. 
Reader methods are (usually) not using extra threads to perform I/O while 
the application is doing something else, therefore, the application has to 
regularly check for chunks until there is one. In this call will the reader 
method actually perform its work, except for data transfers initiated with 
RDMA (Remote Direct Memory Access) networking operations, that are executed 
by the network subsystem independently from the application execution. 

First, we need to tell the reading method how much maximum memory it can use for storing data. If we don't provide this, the method will use as much as needed and it might run out of memory. The allowed amount should be enough to store the largest piece of any variable written by any individual process. Reading methods usually do not work with a finer granulation than this size, unless explicitly documented for a given method. 

\begin{lstlisting}[numbers=left, numberstyle=\color{gray}, stepnumber=2,
                             caption={Read variable with auto selection in chunks from a stream}, label=code:auto_read_chunks]
adios_read_init_method (ADIOS_READ_METHOD_DATASPACES, comm, 
                        "max_chunk_size=100"); // 100 MB 
fp = adios_read_open ("myfile.bp", ADIOS_READ_METHOD_BP, comm,
                      ADIOS_LOCKMODE_CURRENT, 0); // 0: wait forever
vi = adios_inq_var (fp, "P");
adios_schedule_read (fp, s, "P", 0, 1, `\color{red}{\bf NULL}`);
adios_perform_reads (fp, `\color{red}{\bf 0}`);   
// Loop to get chunks
int ck;
ADIOS_VARCHUNK * chunk;
while ( (ck = adios_check_reads (fp, &chunk)) > 0) {
    if (chunk) {
        // process the chunk first, see `\color{javagreen}{\lstlistingname~\ref{code:process_chunk}}`
        ... 
        // free memory of chunk (not the data!)
        adios_free_chunk (chunk);
    } else {
        // no chunk was returned, slow down a little
        sleep(1);
    }
}  
if (ck < 0) {
    // some error happened
    fprintf (stderr, "rank %d: Error during chunk reads: %s\n",
             rank, adios_errmsg());
}
adios_free_varinfo (vi); 
adios_read_close (fp);
adios_read_finalize_method (ADIOS_READ_METHOD_BP);
\end{lstlisting}

A returned chunk contains the integer \emph{id} of the variable (variable name is \verb+fp->varnamelist[chunk->varid]+), its type, a pointer to the data and a pointer to an \verb+ADIOS_SUBSET+ struct, which describes what subset of a variable is returned. ADIOS supports two basic selection types, which can be returned: a single bounding box or a list of points. If the original selection is a bounding box then each chunk will be also a boundingbox representing a subset of the original bounding box. A chunk is usually is the intersection of one writer process' output of the given variable and the original selection. In case of list of points, each chunk will be a list of points too. 

\begin{lstlisting}[numbers=left, numberstyle=\color{gray}, stepnumber=2,firstnumber=13,
                             caption={Processing chunks from a file}, label=code:process_chunk]
      ADIOS_SUBSET * s = chunk->chunk_subset;
      printf ("Variable %s:\n", fp->varnamelist[chunk->varid]);
      switch(s->type) {
      case ADIOS_SUBSET_BOUNDINGBOX:
          printf ("%d-D Bounding Box offset=(%d %d %d) size=(%d %d %d)\n",
              s->u.bb.ndim;
              s->u.bb.start[0], s->u.bb.start[1], s->u.bb.start[2],
              s->u.bb.count[0], s->u.bb.count[1], s->u.bb.count[2]);
          break;
     case ADIOS_SUBSET_POINTS:
          int n;
          for (n=0; n<s->npoints; n++) {
               // One point in 3D is three consecutive values
               //   s->u.points.points[3*n]
               //   s->u.points.points[3*n+1]
               //   s->u.points.points[3*n+2]
          }
          break;
     default:
         fprintf (stderr, "rank %d: Error: unexpected chunk type: %d\n",
                 rank, s->type);
     }  
 \end{lstlisting}



\subsection{Read into user-allocated buffers}
If the application provides the memory for each scheduled read, the only difference 
to the chunked read is that each chunk describes one completed read as it was scheduled.
That is, the returned chunk contains the whole subset of a variable. The code structure 
is thus the same as above, just processing each chunk means processing each variable.


\section {More esoteric scenarios}


\subsection{In situ read: read data locally available on the node}
A special scenario for reading is when the reader application processes data in situ with the writer application, using some of the computing cores of each compute node. Naturally, to avoid cross-node communication, readers want to get data from the writers located on the same node. In Section \ref {section:non_global_vars}, we used a rank-based selection to specify from which writer processes we do want to get data. ADIOS does not support providing location based rank information of the writers to the readers, but the writer itself can write such data into the stream and then rank based reading can be applied. 

A similar scenario is a file stored on a parallel file system. The best transfer bandwidth can be achieved by the file reading method, if it can decide which piece on what disk goes to which reader. In this case, the writer does not know then what information should be shared with the reader. 

Therefore, a special query is defined that lets every staging method to deliver what is considered optimal for that particular method. \lstinline+adios_query_auto()+ lets the reading method to choose which writers' data it will return (in chunks). A staging method will deliver data from those writers that belong to that particular staging process. An in situ method will deliver data from writers that are located on the same compute node that the reader is. Each method has to document how this special case is handled. 

%{\color{red}Question: How does this work if more than one reader process per node is reading???}


\label {label_section_variable_stepping}
\subsection {Variable stepping of variables in a stream}
Usually the number of steps in a file is a global value for all variables and attributes. However, someone may write different variables with different frequencies into a stream. This means that each variable has a different logical step, while in ADIOS the step is the feature of the stream, not of the individual variables. In case of files opened as files, this is straightforward since all read operations use the individual variable's stepping for reading. 

In case of streams, however, those individual counters always equal 1. At each advance, the list of variables is updated, which can be used by the application itself to count how many times a given variable has occurred in the steps before that the reader has advanced to. 

Let's assume \verb+P+ and \verb+Q+ are variables written with different frequencies, and \verb+t+ is a single real value at each step depicting the simulation time. Here is how we can keep track P and Q, with the extension of  \lstlistingname~\ref{code:stream_stepbystep}.

\begin{lstlisting}[numbers=left, numberstyle=\color{gray}, stepnumber=2,firstnumber=18,
                             caption={Processing varying set of variables in a stream},  label=code:stream_variable_stepping]
int varid;
int varid_P, varid_Q;
int count_P = 0, count_Q = 0;
while (adios_errno != err_end_of_stream) {
    // fp->current_step  contains the step we are at
    vi = adios_inq_var (fp, "t");  // get simulation time at this step
    varid_P = varid_Q = -1; 
    for (varid=0; varid < fp->nvars) {
        if (!strcmp("P", fp->var_namelist[varid])) {
            adios_schedule_read_byid (fp, NULL, varid, 0, 1, P);
            count_P++;
            varid_P = varid;
        } else if (!strcmp("Q", fp->var_namelist[varid])) {
            adios_schedule_read_byid (fp, NULL, varid, 0, 1, Q);
            count_Q++;
            varid_Q = varid;
        }
        adios_perform_reads (fp, 1);   
        adios_release_step (fp); // this step is no longer needed
    // process P, Q, then advance the step
    ...
    // 1) to the next available step (arg 0 as false) 
    // 2) with blocking wait (-1 as timeout)
    adios_advance_step (fp, 0, -1);
}
\end{lstlisting}

